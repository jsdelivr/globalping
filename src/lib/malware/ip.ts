import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import type { CustomHelpers, ErrorReport } from 'joi';
import got from 'got';
import validator from 'validator';
import ipaddr from 'ipaddr.js';
import { scopedLogger } from '../logger.js';

const logger = scopedLogger('malware-ip');

export const sourceList = [
	'https://osint.digitalside.it/Threat-Intel/lists/latestips.txt',
	'https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level2.netset',
	'https://raw.githubusercontent.com/stamparm/ipsum/master/levels/2.txt',
	'https://www.spamhaus.org/drop/dropv6.txt',
	'https://lists.blocklist.de/lists/all.txt',
];

export const ipListPath = path.join(path.resolve(), 'data/IP_BLACKLIST.json');

let ipList = new Set<string>();
let ipListCIDR = new Set<ReturnType<typeof ipaddr.parseCIDR>>();

const isFulfilled = <T>(input: PromiseSettledResult<T>): input is PromiseFulfilledResult<T> => input.status === 'fulfilled';

export const query = async (url: string): Promise<string[]> => {
	const { body } = await got(url, {
		timeout: { request: 5000 },
	});

	return body
		.split(/\r?\n/)
		.map(l => l.split(' ')[0] ?? '')
		.filter(l => validator.isIP(l.split('/')[0] ?? ''));
};

export const populateMemList = async (): Promise<void> => {
	const data = JSON.parse(await readFile(ipListPath, 'utf8')) as string[];
	ipList = new Set(data.filter(address => ipaddr.isValid(address)));
	ipListCIDR = new Set(data.filter(address => ipaddr.isValidCIDR(address)).map(address => ipaddr.parseCIDR(address)));
};

export const updateList = async (): Promise<void> => {
	const result = await Promise.allSettled(sourceList.map(source => query(source)));
	const ipList = [ ...new Set(result.flatMap((r) => {
		if (isFulfilled(r)) {
			return r.value;
		}

		logger.error(r.reason);
		return [];
	})) ];

	await writeFile(ipListPath, JSON.stringify(ipList), { encoding: 'utf8' });
};

function isContainedWithinSubnet (target: string, ipList: Set<ReturnType<typeof ipaddr.parseCIDR>>): boolean {
	const targetAddr = ipaddr.parse(target);

	for (const listAddr of ipList) {
		if (targetAddr.kind() === listAddr[0].kind()) {
			if (targetAddr.match(listAddr)) {
				return true;
			}
		}
	}

	return false;
}

export const validate = (target: string): boolean => {
	if (!validator.isIP(target)) {
		return true;
	}

	return !ipList.has(target) && !isContainedWithinSubnet(target, ipListCIDR);
};

export const joiValidate = (value: string, helpers?: CustomHelpers): string | ErrorReport | Error => {
	const isValid = validate(value);

	if (!isValid) {
		if (helpers) {
			return helpers.error('ip.blacklisted');
		}

		throw new Error('ip.blacklisted');
	}

	return String(value);
};
