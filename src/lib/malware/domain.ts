import { writeFile, readFile } from 'node:fs/promises';
import path from 'node:path';
import type { CustomHelpers, ErrorReport } from 'joi';
import got from 'got';
import config from 'config';
import validator from 'validator';
import { scopedLogger } from '../logger.js';

const logger = scopedLogger('malware-domain');

export const sourceList = [
	'https://download.jsdelivr.com/PHISHING_ARMY_BLOCKLIST.txt',
	'https://download.jsdelivr.com/URLHAUS_HOSTFILE.txt',
];

export const domainListPath = path.join(path.resolve(), config.get('data.domainBlacklistPath'));

let domainListArray = new Set<string>();

const isFulfilled = <T>(input: PromiseSettledResult<T>): input is PromiseFulfilledResult<T> => input.status === 'fulfilled';

export const query = async (url: string): Promise<string[]> => {
	const { body } = await got(url, {
		timeout: { request: 5000 },
	});

	const result = body.split(/r?\n?\s+/).filter(l => validator.isFQDN(l));

	return result;
};

export const updateList = async (): Promise<void> => {
	const result = await Promise.allSettled(sourceList.map(source => query(source)));
	const list = [ ...new Set(result.flatMap((r) => {
		if (isFulfilled(r)) {
			return r.value;
		}

		logger.error('Error in domain updateList()', r.reason);
		return [];
	})) ].map(d => d.toLowerCase());

	await writeFile(domainListPath, JSON.stringify(list), { encoding: 'utf8' });
};

export const populateMemList = async (): Promise<void> => {
	const data = await readFile(domainListPath, 'utf8');
	domainListArray = new Set(JSON.parse(data) as string[]);
};

export const validate = (target: string): boolean => !domainListArray.has(target.toLowerCase());

export const joiValidate = (value: string, helpers?: CustomHelpers): string | ErrorReport | Error => {
	const isValid = validate(value);

	if (!isValid) {
		if (helpers) {
			return helpers.error('domain.blacklisted');
		}

		throw new Error('domain.blacklisted');
	}

	return String(value);
};
