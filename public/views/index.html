<head>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
</head>
<body>
  <div class="container">
    <div class="row">
      <div id="app" class="col-12 col-lg-6"></div>
      <div id="probes" class="col-12 col-lg-6"></div>
    </div>
  </div>

  <script src="https://unpkg.com/vue@3"></script>

  <script>
    const probes = () => ({
      data() {
        return {
          probes: [],
        }
      },
      created() {
        this.fetchProbes()
      },
      methods: {
        async fetchProbes() {
          const url = '/v1/probes';
          this.probes = await (await fetch(url)).json()
        },
      },
      template: `
          <div>
            <h2>
              {{ probes.length }} probes available
            </h2>
            <ul>
              <li v-for="probe in probes">
                {{ probe.city }}, {{ probe.country }}
              </li>
            </ul>
          </div>
        `
    });
    Vue.createApp(probes()).mount('#probes')

    const app = () => ({
      data() {
        return {
          query: {
            type: 'ping',
            locations: [],
            target: 'google.com',
            limit: 1
          },
          response: {
            data: null,
            error: null
          },
          measurementId: null,
        }
      },
      watch: {
        measurementId(nId, oId) {
          // prevent loop on empty value
          if (nId) {
            this.resultInterval = setInterval(this.fetchMeasurement.bind(this), 500);
          }
        },
        'response.data.status'(status) {
          if (status === 'finished') {
            clearInterval(this.resultInterval);
          }
        }
      },
      methods: {
        parsedRawOutput(index) {
          const string = this.response.data.results[index].result.rawOutput;

          if (string) {
            return string.replace(/(?:\r\n|\r|\n)/g, '<br>');
          }

          return '';
        },
        submitPostMeasurement(e) {
          e.preventDefault();
          this.buildAndPostMeasurement();
        },
        buildAndPostMeasurement() {
          const measurement = {
            type: this.query.type,
            target: this.query.target
          };

          const locations = this.query.locations.map(({ id, limit, ...l}) => ({
            ...l,
            ...(limit ? { limit } : {})
          }))

          this.postMeasurement(this.query.limit, measurement, locations);
        },
        addNewLocation(e) {
          e.preventDefault();

          const loc = { id: Date.now(), type: '', value: '', limit: 1 }
          this.query.locations.push(loc);
        },
        async postMeasurement(limit = 1, measurement = {}, locations = []) {
          const url = '/v1/measurements'

          const body = {
            measurement,
            locations
          };

          if (!locations.find(l => l.limit)) {
            body.limit = limit;
          }

          const response = await fetch(url, {
            method: 'post',
            body: JSON.stringify(body),
            headers: {
              'content-type': 'application/json'
            }
          });

          if (response.ok) {
            const data = await response.json();
            this.measurementId = data.id;
          } else {
            const error = await response.json();

            this.response = {
              error
            };
          }
        },
        async fetchMeasurement() {
          const url = `/v1/measurements/${this.measurementId}`;

          const response = await fetch(url);

          if (response.ok) {
            const data = await response.json();

            this.response = {
              data
            };
          } else {
            const error = await response.json();

            this.response = {
              error
            };
          }
        }
      },
      template: `
        <h2>
          query
        </h2>
        <form @submit="submitPostMeasurement">
          <div>
            <h3>
              general properties
            </h3>
            <select v-model="query.type">
              <option disabled value="">Please select one</option>
              <option value="ping">ping</option>
            </select>
            <input v-model="query.target" placeholder="target" />
            <input type="number" v-model="query.limit" placeholder="global limit" />
          </div>
          <div>
            <h3>
              location filters
            </h3>
            <ul>
              <li v-for="(m, index) in query.locations">
                <select v-model="query.locations[index].type">
                  <option disabled value="">Please select one</option>
                  <option value="continent">continent</option>
                </select>
                <input v-model="query.locations[index].value" placeholder="value" />
                <input type="number" v-model="query.locations[index].limit" placeholder="global limit" />
              </li>
            </ul>
          </div>
          <div>
            <button @click="addNewLocation">add location</button>
            <button type="submit">measure</button>
          </div>
        </form>
        <div style="color: red;">
          <span>
            {{ response.error && response.error.error.message }}
          </span>
        </div>
        <div>
          {{ query.type }} {{ query.target }} {{ query.limit }}
        </div>
        <div v-if="response.data">
          <span v-for="(result, index) in response.data.results">
            <span v-html="parsedRawOutput(index)">
            </span>
          </span>
        </div>
      `
    });

    Vue.createApp(app()).mount('#app')
  </script>
</body>
